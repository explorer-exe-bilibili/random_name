#include "Application.h"
#include "Window.h"
#include "GLRenderer.h"
#include "FontRenderer.h"
#include <iostream>
#include<GLFW/glfw3.h>

// 前置声明音频管理器（需要实现）
namespace audio {
    class AudioManager {
    public:
        void initialize() { /* 初始化音频系统 */ }
        void playSound(const std::string& soundFile) { /* 播放声音 */ }
        void playMusic(const std::string& musicFile, bool loop = false) { /* 播放背景音乐 */ }
        void stopMusic() { /* 停止背景音乐 */ }
    };
}

// 屏幕管理器内部类实现
class Application::ScreenManager {
public:
    ScreenManager(Application* app) : app(app) {}
    
    void initialize() {
        // 初始化各个屏幕的资源
    }
    
    void render() {
        // 基于应用程序状态渲染当前屏幕
        switch (app->getState()) {
            case AppState::FIRST_SCREEN:
                renderFirstScreen();
                break;
            case AppState::SETTING:
                renderSettingScreen();
                break;
            case AppState::NAME_SCREEN:
                renderNameScreen();
                break;
            case AppState::HISTORY:
                renderHistoryScreen();
                break;
            case AppState::MENU:
                renderMenuScreen();
                break;
        }
    }
    
    void update() {
        // 更新当前屏幕状态
    }
    
    void handleMouseClick(double x, double y) {
        // 处理鼠标点击
    }
    
    void handleKeyPress(int key) {
        // 处理按键
    }
    
private:
    Application* app;
    
    // 各种屏幕的渲染方法
    void renderFirstScreen() {
        // 渲染首屏
    }
    
    void renderSettingScreen() {
        // 渲染设置屏幕
    }
    
    void renderNameScreen() {
        // 渲染名称屏幕
    }
    
    void renderHistoryScreen() {
        // 渲染历史屏幕
    }
    
    void renderMenuScreen() {
        // 渲染菜单屏幕
    }
};

// 应用程序单例实现
Application& Application::getInstance() {
    static Application instance;
    return instance;
}

Application::Application()
    : currentState(AppState::FIRST_SCREEN),
      running(false),
      floatWindowVisible(false),
      lastFrameTime(0.0),
      frameTime(0.0),
      frameCount(0),
      fps(0.0f) {
}

Application::~Application() {
    terminate();
}

bool Application::init(int width, int height, const std::string& title) {
    // 初始化GLFW
    if (!Window::initGLFW()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        return false;
    }
    
    // 初始化主窗口
    if (!initWindow(width, height, title)) {
        std::cerr << "Failed to create window" << std::endl;
        return false;
    }
    
    // 初始化渲染器
    if (!initRenderers()) {
        std::cerr << "Failed to initialize renderers" << std::endl;
        return false;
    }
    
    // 初始化音频系统
    if (!initAudio()) {
        std::cerr << "Failed to initialize audio" << std::endl;
        // 继续执行，音频是可选的
    }
    
    // 加载资源
    loadTextures();
    loadFonts();
    
    // 初始化屏幕管理器
    screenManager = std::make_unique<ScreenManager>(this);
    screenManager->initialize();
    
    // 设置回调
    window->setResizeCallback([this](int w, int h) {
        handleWindowResize(w, h);
    });
    
    window->setKeyCallback([this](int key, int scancode, int action, int mods) {
        handleKeyEvent(key, scancode, action, mods);
    });
    
    window->setMouseButtonCallback([this](int button, int action, int mods) {
        handleMouseEvent(button, action, mods);
    });
    
    running = true;
    return true;
}

void Application::run() {
    // 主循环
    lastFrameTime = glfwGetTime();
    frameCount = 0;
    
    while (running && !window->shouldClose()) {
        // 计算帧率
        double currentTime = glfwGetTime();
        double delta = currentTime - lastFrameTime;
        frameCount++;
        
        if (delta >= 1.0) { // 每秒更新一次FPS
            fps = static_cast<float>(frameCount) / static_cast<float>(delta);
            frameCount = 0;
            lastFrameTime = currentTime;
        }
        
        // 处理输入
        handleEvents();
        
        // 更新逻辑
        update();
        
        // 渲染
        render();
    }
}

void Application::terminate() {
    if (floatWindow) {
        floatWindow.reset();
    }
    
    if (renderer) {
        renderer.reset();
    }
    
    if (fontRenderer) {
        fontRenderer.reset();
    }
    
    if (window) {
        window.reset();
    }
    
    // 终止GLFW
    Window::terminateGLFW();
    
    running = false;
}

void Application::setState(AppState state) {
    if (currentState != state) {
        changeState(state);
    }
}

void Application::loadTextures() {
    // 加载各种纹理
    // 这里将替换原有的explorer::Load()函数的功能
}

void Application::loadFonts() {
    // 加载字体
    if (fontRenderer) {
        // 加载默认字体
#ifdef _WIN32
        // 在Windows上加载系统字体
        fontRenderer->loadFontFromSystem(L"SDK_SC_Web", 24);
#else
        // 在其他平台上从文件加载字体
        fontRenderer->loadFont("fonts/default.ttf", 24);
#endif
    }
}

int Application::getScreenWidth() const {
    return window ? window->getWidth() : 0;
}

int Application::getScreenHeight() const {
    return window ? window->getHeight() : 0;
}

void Application::showFloatWindow(bool show) {
    floatWindowVisible = show;
    
    if (show && !floatWindow) {
        // 创建悬浮窗
        int floatWidth = getScreenWidth() * 0.05;
        int floatHeight = getScreenWidth() * 0.05;
        int floatX = getScreenWidth() * 0.8;
        int floatY = getScreenHeight() * 0.8;
        
        floatWindow = std::make_unique<Window>("Float", floatWidth, floatHeight, false);
        if (floatWindow->init()) {
            floatRenderer = std::make_unique<GLRenderer>(floatWindow.get());
            // 加载悬浮窗纹理
        }
    }
    else if (!show && floatWindow) {
        floatWindow.reset();
        floatRenderer.reset();
    }
}

bool Application::initWindow(int width, int height, const std::string& title) {
    window = std::make_unique<Window>(title, width, height, false);
    return window->init();
}

bool Application::initRenderers() {
    if (!window) return false;
    
    // 创建渲染器
    renderer = std::make_unique<GLRenderer>(window.get());
    
    // 创建字体渲染器
    fontRenderer = std::make_unique<FontRenderer>();
    if (!fontRenderer->init()) {
        std::cerr << "Failed to initialize font renderer" << std::endl;
        return false;
    }
    
    // 设置字体渲染器的投影矩阵
    glm::mat4 projection = glm::ortho(0.0f, static_cast<float>(window->getWidth()), 
                               static_cast<float>(window->getHeight()), 0.0f);
    fontRenderer->setProjection(projection);
    
    return true;
}

bool Application::initAudio() {
    audioManager = std::make_unique<audio::AudioManager>();
    audioManager->initialize();
    return true;
}

void Application::handleEvents() {
    // 处理窗口事件
    window->pollEvents();
    
    // 如果存在悬浮窗，也处理其事件
    if (floatWindow && floatWindowVisible) {
        floatWindow->pollEvents();
    }
}

void Application::handleWindowResize(int width, int height) {
    if (renderer) {
        renderer->resizeViewport(width, height);
    }
    
    if (fontRenderer) {
        glm::mat4 projection = glm::ortho(0.0f, static_cast<float>(width), 
                                   static_cast<float>(height), 0.0f);
        fontRenderer->setProjection(projection);
    }
    
    if (resizeCallback) {
        resizeCallback(width, height);
    }
}

void Application::handleKeyEvent(int key, int scancode, int action, int mods) {
    // 特殊按键处理
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
        // ESC键处理
        if (currentState != AppState::MENU) {
            setState(AppState::MENU);
        }
    }
    
    // 传递给外部回调
    if (keyCallback) {
        keyCallback(key, scancode, action, mods);
    }
}

void Application::handleMouseEvent(int button, int action, int mods) {
    if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS) {
        // 鼠标左键点击
        double mouseX, mouseY;
        window->getMousePosition(mouseX, mouseY);
        screenManager->handleMouseClick(mouseX, mouseY);
    }
    
    // 传递给外部回调
    if (mouseButtonCallback) {
        mouseButtonCallback(button, action, mods);
    }
}

void Application::render() {
    // 清除屏幕
    renderer->clear(Color(0.0f, 0.0f, 0.0f, 1.0f));
    
    // 渲染当前屏幕
    screenManager->render();
    
    // 显示FPS（如果调试模式开启）
    // if (debugMode) {
    fontRenderer->renderText("FPS: " + std::to_string(static_cast<int>(fps)), 
                           10, 10, 1.0f, glm::vec4(1.0f, 1.0f, 1.0f, 1.0f));
    // }
    
    // 交换缓冲区
    renderer->flush();
    
    // 渲染悬浮窗（如果可见）
    if (floatWindow && floatWindowVisible) {
        floatWindow->makeContextCurrent();
        floatRenderer->clear(Color(0.0f, 0.0f, 0.0f, 0.0f));
        // 渲染悬浮窗内容
        floatRenderer->flush();
        window->makeContextCurrent(); // 恢复主窗口上下文
    }
}

void Application::update() {
    // 更新游戏状态
    screenManager->update();
    
    // 更新悬浮窗
    if (floatWindowVisible) {
        // 更新悬浮窗位置或动画
    }
}

void Application::changeState(AppState newState) {
    // 保存当前状态
    AppState previousState = currentState;
    
    // 更新状态
    currentState = newState;
    
    // 根据状态变化执行额外操作
    // 例如播放音频、加载资源等
}