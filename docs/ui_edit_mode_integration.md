# UI编辑模式集成完成

## 功能概述

已成功将Button编辑模式功能集成到Screen系统中，现在所有Screen子类都自动支持运行时UI编辑功能。

## 主要功能

### 1. 编辑模式操作

- **F2键**: 切换编辑模式开/关

### 2. 鼠标编辑操作

- **点击按钮内部**: 开始移动按钮
- **点击编辑手柄**: 调整按钮大小（8个调整点：4个角落 + 4个边框中点）
- **拖拽**: 实时预览变化
- **释放鼠标**: 自动保存布局到配置文件

### 3. 视觉反馈

- 编辑模式下显示蓝色边框
- 8个白色边框的蓝色调整手柄
- 实时拖拽预览

### 4. 布局管理

- 每个屏幕的布局独立保存
- 支持最小尺寸限制（默认10x10像素）
- 支持屏幕边界限制
- 自动保存到配置文件
- 重启程序后布局自动加载

## 修改的文件

### 头文件修改

1. **include/core/baseItem/Button.h**
   - 添加编辑模式相关的方法声明
   - 修改SetRegion和resetRegion方法以支持编辑手柄更新

2. **include/core/screen/base.h**
   - 添加编辑模式相关成员变量
   - 添加编辑模式相关方法声明

3. **include/mainloop.h**
   - 添加MouseMoveEvent回调函数声明

### 源文件修改

1. **src/core/baseItem/Button.cpp**
   - 实现完整的编辑模式功能
   - 添加SetEditMode和SetOnEditComplete方法实现

2. **src/core/screen/base.cpp**
   - 修改Click方法支持编辑模式
   - 修改Draw方法绘制编辑覆盖层
   - 实现布局保存/加载/重置功能

3. **src/mainloop.cpp**
   - 修改KeyEvent函数添加F2/F3快捷键
   - 修改MouseButtonEvent函数支持编辑模式
   - 添加MouseMoveEvent函数处理拖拽

4. **src/main.cpp**
   - 注册鼠标移动回调函数

## 配置文件结构

布局数据保存在配置文件中，格式如下：

```json
{
  "screen_0_exit": {
    "x": 0.9,
    "y": 0.05,
    "width": 0.08,
    "height": 0.06
  },
  "screen_0_button_0": {
    "x": 0.1,
    "y": 0.2,
    "width": 0.2,
    "height": 0.1
  }
}
```

## 使用方法

### 开发者使用

1. 编译项目
2. 运行程序
3. 按F2进入编辑模式
4. 拖拽按钮调整布局
5. 按F2退出编辑模式
6. 按F3重置布局（如需要）

### 最终用户使用

- 提供一个设置选项来启用/禁用编辑模式
- 可以在设置中添加"重置所有布局"按钮

## 技术特性

### 安全性

- 所有编辑操作都有边界检查
- 最小尺寸限制防止按钮消失
- 线程安全的实现

### 性能

- 只在编辑模式下绘制编辑覆盖层
- 高效的事件处理
- 最小化不必要的重绘

### 兼容性

- 无侵入性设计，现有代码无需修改
- 所有Screen子类自动继承编辑功能
- 向后兼容现有配置文件

## 扩展可能

1. **添加网格对齐功能**
2. **支持多选和批量操作**
3. **添加撤销/重做功能**
4. **导入/导出布局模板**
5. **添加更多调整手柄样式**

## 编译后测试

编译完成后，运行程序并测试以下功能：

1. **基本编辑功能**：
   - 按F2进入编辑模式，验证按钮显示蓝色边框和手柄
   - 拖拽按钮到新位置
   - 使用8个手柄调整按钮大小
   - 按F2退出编辑模式

2. **布局持久化测试**：
   - 在编辑模式下移动/调整按钮
   - 退出编辑模式，确认变化立即生效
   - 重启程序，验证修改的布局自动加载（不需要进入编辑模式）
   - 按F3重置布局到默认状态

3. **多屏幕测试**：
   - 在不同屏幕间切换，验证每个屏幕的布局独立保存
   - 修改一个屏幕的布局不影响其他屏幕

## 问题修复记录

### 重启后布局不加载问题（已修复）

**问题描述**：移动按钮后重启程序没有显示移动后的位置，但按F2进入编辑模式就会瞬移到修改后的位置。

**根本原因**：

- 布局保存/加载机制本身工作正常
- 问题在于屏幕进入时，`reloadButtonsRegion()`方法会重新设置按钮的默认位置
- 自定义布局只在进入编辑模式时才会被加载

**修复方案**：

- 在`Screen::SwitchToScreen()`和`Screen::updateTransition()`中添加自动布局加载
- 当屏幕切换完成后，自动检查并加载自定义布局（如果存在）
- 确保重启后自定义布局立即生效，无需进入编辑模式

**修改文件**：

- `src/core/screen/base.cpp`: 在屏幕切换逻辑中添加自动布局加载

### 子类Draw方法中编辑覆盖层缺失问题（已修复）

**问题描述**：在没有使用基类`Screen::Draw()`函数的子类中都没有显示拖拽框和编辑手柄。

**根本原因**：

- 部分Screen子类（SettingScreen、VideoScreen、NameScreen、ListNameScreen）重写了`Draw()`方法
- 这些子类没有调用基类的`Screen::Draw()`，而是自己实现绘制逻辑
- 基类的`Screen::Draw()`包含编辑覆盖层的绘制代码`DrawEditOverlays()`
- 因此这些子类在编辑模式下不会显示编辑框和手柄

**修复方案**：

- 在每个重写了`Draw()`方法的子类中，在绘制逻辑末尾添加编辑覆盖层绘制
- 添加条件检查`if (editModeEnabled) { DrawEditOverlays(); }`

**修改文件**：

- `src/core/screen/SettingScreen/SettingScreen.cpp`: 在Draw方法末尾添加编辑覆盖层绘制
- `src/core/screen/VideoScreen.cpp`: 在Draw方法末尾添加编辑覆盖层绘制  
- `src/core/screen/NameScreen.cpp`: 在Draw方法末尾添加编辑覆盖层绘制
- `src/core/screen/ListNameScreen.cpp`: 在Draw方法末尾添加编辑覆盖层绘制

### Region 1:1比例编辑兼容性问题（已修复）

**问题描述**：Region会在yend <= 0时返回高以兼容需要1:1比例显示的组件，但编辑器不能正常解析这个特性。

**根本原因**：

- Region类有特殊逻辑：当`yend <= 0`时，`getyend()`返回1:1比例的高度
- 编辑器使用`getOriginYEnd()`获取原始坐标进行编辑
- 编辑后直接调用`setyend()`设置新值，破坏了1:1比例逻辑
- 导致1:1比例组件在编辑后失去正方形特性

**修复方案**：

- **重构Region类**：添加`aspectRatio1to1`标志位明确标识1:1比例模式
- **改进构造函数**：自动检测`yend <= 0`并设置标志位
- **更新getOriginYEnd()**：为1:1比例返回正确的编辑坐标
- **增强编辑器逻辑**：在编辑模式下保持1:1比例特性
- **添加显式控制**：提供`setAspectRatio1to1()`方法

**修改文件**：

- `include/core/baseItem/Base.h`: 重构Region类，添加1:1比例支持
- `src/core/baseItem/Base.cpp`: 更新getyend()实现
- `src/core/baseItem/Button.cpp`: 增强编辑器以支持1:1比例

**新功能**：

- `Region::isAspectRatio1to1()`: 检查是否为1:1比例模式
- `Region::setAspectRatio1to1(bool)`: 显式启用/禁用1:1比例
- `Region::getOriginYEnd()`: 为1:1比例返回计算后的实际yend值
- 编辑器在1:1模式下自动保持正方形约束

**向后兼容性**：

- 原有的`yend <= 0`逻辑完全保留
- 现有代码无需修改即可继续工作
- 新功能是可选的增强，不影响现有功能

1. 正常模式下按钮点击功能正常
2. 按F2进入编辑模式，按钮周围出现蓝色边框和调整手柄
3. 拖拽按钮内部可以移动按钮
4. 拖拽调整手柄可以改变按钮大小
5. 按F2退出编辑模式，编辑覆盖层消失
6. 重启程序，布局保持之前的修改
7. 按F3可以重置布局到默认状态

所有功能已集成完毕，可以直接编译和使用！
